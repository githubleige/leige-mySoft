metthodProxy其实就是一个cglib构造的一个对象，目的就是不通过反射调用方法（JDK动态代理如果需要调用代理对象
的方法，就是传入的method对象，不可避免的需要用到反射的方法进行代用，但是用反射的方法进行调用在效率上可能出现
一些偏差，原因：反射的本质就是通过class对象来进行一些操作，class在方法区构造出来，其实就是在加载*.calss文件
进行加载连接初始化，通过对字节码的学习可以知道，class数据结构是一个边长的数据结构，要想知道某一个属性的具体
位置就需要进行逐一解析，这是非常影响效率的，所以我们cglib通过生成fastClass的方式来解决不通过反射的方法来进行
方法调用，具体过程如下：）
我们以调用methodProxy.invokeSuper(o, objects);例子来进行详细的介绍。假设我现在调用userService.test();
参数：o是cglib生成的代理对象(子类的对象)  class com.zhouyu.UserService$$EnhancerByCGLIB$$4d890297
      objects：方法入参

methodProxy生成过程：
首先通过UserService$$EnhancerByCGLIB$$4d890297的静态代码块进行初始化
static {
        CGLIB$STATICHOOK1();
}
Method CGLIB$test$0$Method = ReflectUtils.findMethods(new String[]{"test", "()V"}, (var1 = Class.forName("com.zhouyu.UserService")).getDeclaredMethods())[0];
MethodProxy CGLIB$test$0$Proxy = MethodProxy.create(var1, var0, "()V", "test", "CGLIB$test$0");
// Class var0 = Class.forName("com.zhouyu.UserService$$EnhancerByCGLIB$$4d890297");
// Class var1 = Class.forName("com.zhouyu.UserService");
CGLIB$test$0$Method就是把void test()方法的Method对象赋值给它
CGLIB$test$0$Proxy就是void test()方法在代理子类中生成代理方法（随便怎么叫），
每个方法在UserService$$EnhancerByCGLIB$$4d890297都会有一个对应的代理方法，void test()对应的代理方法就是：
final void CGLIB$test$0() {
        super.test();
    }

现在开始根据这些参数开始初始化MethodProxy：
public class MethodProxy {
    private Signature sig1; //这就是一个方法签名（里面有方法的名字，以及返回值和参数类型：（"test","()V"））
    private Signature sig2;（"CGLIB$test$0","()V"）
    private MethodProxy.CreateInfo createInfo;//这也是一个重要的属性，下面介绍，主要用来生成对应类的fastClass
    private final Object initLock = new Object();//就是一个锁对象
    private volatile MethodProxy.FastClassInfo fastClassInfo;//根据createInfo生成的对象容器，这个只有在调用MethodProxy的相关invoke方法才进行初始化
    ……
}

private static class CreateInfo {
        Class c1;//就是上面的var1  Class.forName("com.zhouyu.UserService");
        Class c2;//就是上面的var0  Class.forName("com.zhouyu.UserService$$EnhancerByCGLIB$$4d890297");
        NamingPolicy namingPolicy; //生成对应类的fastClass的名字的命名策略（默认）
        GeneratorStrategy strategy; //生成对应类的fastClass的方法策略（默认）
        boolean attemptLoad;//生成Class对象是否立即加载（默认值）
        ……
}
//target只能是UserService不能是UserService$$EnhancerByCGLIB$$4d890297
进行methodProxy.invoke(target, objects);方法的调用，
初始化private volatile FastClassInfo fastClassInfo;
private static class FastClassInfo
    {


        FastClass f1;// 根据Class var1 = Class.forName("com.zhouyu.UserService");生成的FastClass
        FastClass f2;//根据Class var0 = Class.forName("com.zhouyu.UserService$$EnhancerByCGLIB$$4d890297");生成的FastClass
        int i1;// private Signature sig1（（"test","()V"）））;在var1中的方法坐标
        int i2;// private Signature sig2;（"CGLIB$test$0","()V"）在var0中的方法坐标
    }

 初始化好的 fastClassInfo = fci;//就是复制给上面的private volatile MethodProxy.FastClassInfo fastClassInfo;

 执行：
 return fastClassInfo.f1.invoke(fastClassInfo.i1, obj, args);
 进入invoke方法：var2只能传UserService对象，不能传UserService$$EnhancerByCGLIB$$4d890297对象，否则无限循环调用这个方法，抛出Exception in thread "main" java.lang.StackOverflowError
UserService$$FastClassByCGLIB$$4fef7899的 public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
         UserService var10000 = (UserService)var2;
         //方法坐标
         int var10001 = var1;

         try {
             switch(var10001) {
             case 0:
                 var10000.test();
                 return null;
             case 1:
                 return new Boolean(var10000.equals(var3[0]));
             case 2:
                 return var10000.toString();
             case 3:
                 return new Integer(var10000.hashCode());
             }
         } catch (Throwable var4) {
             throw new InvocationTargetException(var4);
         }

         throw new IllegalArgumentException("Cannot find matching method/constructor");
     }


现在看另一个方法：
o是UserService$$EnhancerByCGLIB$$4d890297对象，只能是UserService$$EnhancerByCGLIB$$4d890297对象，如果传UserService
会抛出Exception in thread "main" java.lang.ClassCastException: com.zhouyu.UserService cannot be cast to com.zhouyu.UserService$$EnhancerByCGLIB$$4d890297
原因是因为下面的代码有一行是这样的：
UserService$$EnhancerByCGLIB$$4d890297 var10000 = (UserService$$EnhancerByCGLIB$$4d890297)o;
真实的对象是UserService，UserService$$EnhancerByCGLIB$$4d890297 只是子类。父类不能强转子类
methodProxy.invokeSuper(o, objects);
其他都和上面一样。但是最后一行不一样：
return fastClassInfo.f2.invoke(fci.i2, obj, args);
进入（4d890297代表的就是UserService$$EnhancerByCGLIB$$4d890297类）
UserService$$EnhancerByCGLIB$$4d890297$$FastClassByCGLIB$$6ea3bb5e的
 public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        4d890297 var10000 = (4d890297)var2;
        int var10001 = var1;

        try {
            switch(var10001) {
            case 0:
                return new Boolean(var10000.equals(var3[0]));
            case 1:
                return var10000.toString();
            case 2:
                return new Integer(var10000.hashCode());
            case 3:
                return var10000.clone();
            case 4:
                return var10000.newInstance((Callback[])var3[0]);
            case 5:
                return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);
            case 6:
                return var10000.newInstance((Callback)var3[0]);
            case 7:
                var10000.test();
                return null;
            case 8:
                var10000.setCallbacks((Callback[])var3[0]);
                return null;
            case 9:
                var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);
                return null;
            case 10:
                return var10000.getCallbacks();
            case 11:
                return var10000.getCallback(((Number)var3[0]).intValue());
            case 12:
                4d890297.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);
                return null;
            case 13:
                4d890297.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);
                return null;
            case 14:
                return var10000.CGLIB$toString$2();
            case 15:
                var10000.CGLIB$test$0();
                return null;
            case 16:
                return new Integer(var10000.CGLIB$hashCode$3());
            case 17:
                return var10000.CGLIB$clone$4();
            case 18:
                return new Boolean(var10000.CGLIB$equals$1(var3[0]));
            case 19:
                4d890297.CGLIB$STATICHOOK1();
                return null;
            case 20:
                return 4d890297.CGLIB$findMethodProxy((Signature)var3[0]);
            }
        } catch (Throwable var4) {
            throw new InvocationTargetException(var4);
        }

        throw new IllegalArgumentException("Cannot find matching method/constructor");
    }


fastClass里面的public int getIndex(Signature var1)方法相当于给fastClss的原来类的每个方法赋予一个坐标，下面只要穿这个
坐标就可以进行调用了

