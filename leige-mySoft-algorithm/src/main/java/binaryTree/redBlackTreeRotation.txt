红黑树对应新插入元素的三种情况，以及处理策略（注意刚插入的元素对应的节点颜色都是红色）：
Case 1	现象说明:当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。
处理策略:
(01) 将“父节点”设为黑色。
(02) 将“叔叔节点”设为黑色。
(03) 将“祖父节点”设为“红色”。
(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。

Case 2	现象说明:当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子。
处理策略:
(01) 将“父节点”作为“新的当前节点”。
(02) 以“新的当前节点”为支点进行左旋。

Case 3	现象说明:当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子
处理策略:
(01) 将“父节点”设为“黑色”。
(02) 将“祖父节点”设为“红色”。
(03) 以“祖父节点”为支点进行右旋。

每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！这里说的叶子节点其实就是二叉树中的
叶子节点的左右空指针,为什么这么做？]
原因分析（会导致链表的出现），假设是升序树（左子树的值小于root,右子树的值大于root）:
第一步、刚开始插入元素是10,黑色的节点（因为是第一个节点，那么就是root节点，root节点必须是黑色的）
第二步、插入元素9,因为是小于放在左边，红色节点
第三步、插入元素是8，继续放在左边，这个时候会判断父节点和叔叔节点，如果不把null算作节点的话，会出现为了满足条件把9变成黑色
第四步、插入7，还是左边，因为不允许把null节点当做节点，导致7还是没有叔叔节点，为了满足条件把8变成黑色节点
……继续6，5,4,3,2,1这样的话就变成链表了。lgn的时间复杂度不复存在
如果把每个真实有值的节点的null都当做黑色节点，那么上面的情况就会在插入的情况下进行平衡，形成真实有效的二叉树

一般在Case 3进行处理后就不会再需要继续旋转平衡了，原因分析：
1、Case 3的前提条件就是：当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子
2、根据上面条件1，其实有一个隐含的条件可以推出：当前节点的兄弟节点（parent.right）肯定是黑色，两种情况：
一、parent.right==null
二、parent.right!=null,如果是红色的话那么此时就会出现parent的左右孩子都是红色，因为这程序是一个节点修正一次，不会出现这种情况。在换句话说，即使出现了这请情况，
那么也是先左旋在右旋。各种推论都能推翻parent.right是红色的结论
3、现在确定当前节点的兄弟节点是黑色的，在右旋的时候以祖父节点进行右旋，那么结果就是parent成为根节点，gparent成为parent的右子树。
   parent原来的右子树（parent.right）变成了gparent的左子树（gparent.left）.因为旋转后：parent成为根节点，且是黑色。gparent是红色，唯一变化的是
   gparent换了一个左子树，左子树的根节点就是上面2的黑色节点，整个红黑树的其他的结构没变，肯定继续满足红黑树要求，综上得出：右旋后不需要继续调整